<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Getting compilers to the right thing #  We&rsquo;re going to look at how to convince the compiler to vectorise a loop the way we want it to.
As our starting point we&rsquo;ll use a C version of the GEMM micro-kernel used in the BLIS framework.
Rather than doing this on Hamilton, since we&rsquo;re not actually going to run the code, we will use the Compiler explorer which is an online frontend to trying out lots of different compilers."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Compiler feedback and the BLIS DGEMM"><meta property="og:description" content="Getting compilers to the right thing #  We&rsquo;re going to look at how to convince the compiler to vectorise a loop the way we want it to.
As our starting point we&rsquo;ll use a C version of the GEMM micro-kernel used in the BLIS framework.
Rather than doing this on Hamilton, since we&rsquo;re not actually going to run the code, we will use the Compiler explorer which is an online frontend to trying out lots of different compilers."><meta property="og:type" content="article"><meta property="og:url" content="https://teaching.wence.uk/comp52315/exercises/exercise09/"><meta property="article:modified_time" content="2022-04-07T18:18:31+01:00"><title>Compiler feedback and the BLIS DGEMM | COMP52315 – Performance Engineering</title><link rel=icon href=/comp52315/favicon.svg type=image/x-icon><link rel=stylesheet href=/comp52315/book.min.0cb0b7d6a1ed5d0e95321cc15edca4d6e9cc406149d1f4a3f25fd532f6a3bb38.css integrity="sha256-DLC31qHtXQ6VMhzBXtyk1unMQGFJ0fSj8l/VMvajuzg="></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><div class=book-brand><img class=book-center src=/comp52315/logo.svg alt=Logo><h2><a href=/comp52315>COMP52315 – Performance Engineering</a></h2></div><ul><li><span>Administrivia</span><ul><li><a href=/comp52315/setup/contact/>Contact details</a></li><li><a href=/comp52315/setup/hamilton/>Hamilton accounts</a></li><li><a href=/comp52315/setup/configuration/>ssh configuration</a></li><li><a href=/comp52315/setup/unix/>Unix resources</a></li></ul></li><li><span>Exercises</span><ul><li><a href=/comp52315/exercises/exercise01/>Sum reductions</a></li><li><a href=/comp52315/exercises/exercise02/>Caches</a></li><li><a href=/comp52315/exercises/exercise03/>Memory bandwidth</a></li><li><a href=/comp52315/exercises/exercise04/>Roofline analysis</a></li><li><a href=/comp52315/exercises/exercise05/>Models and measurements</a></li><li><a href=/comp52315/exercises/exercise06/>Profiling</a></li><li><a href=/comp52315/exercises/exercise07/>Loop tiling matrix transpose</a></li><li><a href=/comp52315/exercises/exercise08/>Loop tiling matrix-matrix multiplication</a></li><li><a href=/comp52315/exercises/exercise09/ class=active>Compiler feedback and the BLIS DGEMM</a></li><li><a href=/comp52315/exercises/exercise10/>Stencil layer conditions</a></li></ul></li><li><span>Notes</span><ul><li><a href=/comp52315/notes/introduction/>Introduction</a></li><li><a href=/comp52315/notes/memory/>The memory hierarchy</a></li><li><a href=/comp52315/notes/roofline/>Performance models: roofline</a></li><li><a href=/comp52315/notes/measurements/>Measurement and profiling</a></li><li><a href=/comp52315/notes/tiling/>Cache blocking/tiling</a></li></ul></li><li><a href=/comp52315/slides/>Slides</a></li><li><a href=/comp52315/coursework/>Coursework: fast finite elements</a><ul></ul></li><li><a href=/comp52315/resources/>Further resources</a></li><li><a href=/comp52315/acknowledgements/>Acknowledgements</a></li><li><span>Past editions</span><ul><li><a href=/comp52315/past-editions/2020-21/>2020/21</a><ul></ul></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/comp52315/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Compiler feedback and the BLIS DGEMM</strong>
<label for=toc-control><img src=/comp52315/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#getting-compilers-to-the-right-thing>Getting compilers to the right thing</a><ul><li><a href=#does-vectorisation-occur>Does vectorisation occur</a></li><li><a href=#vectorising-the-correct-loops>Vectorising the correct loops</a></li><li><a href=#providing-more-detailed-information>Providing more detailed information</a></li><li><a href=#trying-to-maximise-throughput>Trying to maximise throughput</a></li><li><a href=#putting-it-together>Putting it together</a></li></ul></li></ul></nav></aside></header><article class=markdown><blockquote class="book-hint warning"><span>This course page was updated until March 2022 when I left Durham University.
The materials herein are therefore not necessarily still in date.</span></blockquote><h1 id=getting-compilers-to-the-right-thing>Getting compilers to the right thing
<a class=anchor href=#getting-compilers-to-the-right-thing>#</a></h1><p>We&rsquo;re going to look at how to convince the compiler to
vectorise a loop the way we want it to.</p><p>As our starting point we&rsquo;ll use a C version of the <a href=https://teaching.wence.uk/comp52315/code/exercise09/micro-kernel.c>GEMM
micro-kernel</a> used in the <a href=https://github.com/flame/blis/>BLIS
framework</a>.</p><p>Rather than doing this on Hamilton, since we&rsquo;re not actually going to
run the code, we will use the <a href=https://gcc.godbolt.org>Compiler
explorer</a> which is an online frontend to
trying out lots of different compilers. I&rsquo;ve set up a <a href=https://gcc.godbolt.org/z/aTnfZE>pre-filled
version</a>.</p><h2 id=does-vectorisation-occur>Does vectorisation occur
<a class=anchor href=#does-vectorisation-occur>#</a></h2><p>Use <code>-xBROADWELL -O2</code> as the optimsation flags. What does the
vectorisation report say? Which loop was vectorised?</p><p>The default blocking factors (<code>MR</code> and <code>NR</code>) are both 1. Given that
AVX registers can hold four doubles, it makes sense to use larger
blocks.</p><blockquote class=exercise><h3>Exercise</h3><span>Try with some larger blocks and <code>-O3</code> instead of <code>-O2</code></span></blockquote><blockquote class=question><h3>Question</h3><span>Which loop, if any, was vectorised this time?</span></blockquote><h2 id=vectorising-the-correct-loops>Vectorising the correct loops
<a class=anchor href=#vectorising-the-correct-loops>#</a></h2><p>Since the <code>i</code> loop is stride-1, it really makes sense to vectorise the
innermost loop. Try and convince the compiler to do so.</p><blockquote class=question><h3>Question</h3><span><p>Compare the estimated speedup the compiler reports for the original
loop vectorisation choice and the new one.</p><p>What do you observe?</p></span></blockquote><h2 id=providing-more-detailed-information>Providing more detailed information
<a class=anchor href=#providing-more-detailed-information>#</a></h2><p>Part of the problem is that the compiler assumes that the array
accesses are not aligned to cache line boundaries (or vector
registers). Its cost model knows that these are more expensive than if
the data are aligned. However, this drives some bad decisions. We can
help the compiler by letting it know the byte alignment of the arrays.
Use <a href=https://software.intel.com/en-us/articles/data-alignment-to-assist-vectorization><code>__assume_aligned(PTR, 64)</code></a>
to promise to the compiler that the given pointer is 64-byte aligned.</p><blockquote class=question><h3>Question</h3><span><p>Try adding alignment assumptions before the start of the loop nest.</p><p>What happens to the estimated speedup?</p></span></blockquote><h2 id=trying-to-maximise-throughput>Trying to maximise throughput
<a class=anchor href=#trying-to-maximise-throughput>#</a></h2><p>One thing you may have noticed is that the compiler performs a <em>loop
interchange</em>. We have a triply nested loop</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>l</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>l</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>...;</span> <span style=color:#111>l</span><span style=color:#f92672>++</span><span style=color:#111>)</span> <span style=color:#75715e>/* loop 1 */</span>
  <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>j</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>j</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>...;</span> <span style=color:#111>j</span><span style=color:#f92672>++</span><span style=color:#111>)</span> <span style=color:#75715e>/* loop 2 */</span>
    <span style=color:#00a8c8>for</span> <span style=color:#111>(</span><span style=color:#111>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span><span style=color:#111>;</span> <span style=color:#111>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#111>...;</span> <span style=color:#111>i</span><span style=color:#f92672>++</span><span style=color:#111>)</span> <span style=color:#75715e>/* loop 3 */</span>
</code></pre></div><p>But when I run things, I see that the compiler reports it reordered
the loops from order <code>(1 2 3)</code> to <code>(2 1 3)</code>. It then attempts to
vectorise the innermost loop and unroll the middle loop. This loop is
now not fixed length.</p><p>Again, this is an example where the compiler&rsquo;s cost model is
incorrect. We can help it out again by telling it to unroll the <code>j</code>
loop with <code>#pragma unroll</code>.</p><p>We now need to pick good values for the <code>NR</code> and <code>MR</code> parameters.
Broadwell chips have 16 AVX registers, which is enough to store 64
double precision numbers. Given this information, what do you think
the best blocking factors might be. Note that since <code>B[j]</code> is not
stride-1 in the innermost loop, to vectorise the FMA, we need to
replicate the value of <code>B[j]</code> over all lanes of the vector register.
That is, inside the <code>i</code> loop, we need as many registers for <code>B</code> as the
unroll factor of the <code>j</code> loop.</p><blockquote class=question><h3>Question</h3><span>What&rsquo;s the maximum estimated speedup you can achieve?</span></blockquote><h2 id=putting-it-together>Putting it together
<a class=anchor href=#putting-it-together>#</a></h2><p>The subdirectory <code>code/exercise09/blis-gemm/</code> contains a complete
implementation of this scheme (I don&rsquo;t have optimal parameters
though). You can edit the <code>parameters.h</code> file to set the blocking
parameters <code>MR</code> and <code>NR</code>, you&rsquo;ll also need to edit <code>micro-kernel.c</code> to
annotate the loops with the pragmas you found to be useful on the
compiler explorer.</p><blockquote class=exercise><h3>Exercise</h3><span><p>Set all blocking five blocking parameters in <code>parameters.h</code> to 1, and
compile the code. Keep track of the values for <code>MC</code>, <code>KC</code>, and <code>NC</code>
since we&rsquo;ll use them later.</p><p>Run for a range of matrix sizes between 100 and 2000. What performance
do you observe?</p></span></blockquote><blockquote class=exercise><h3>Exercise</h3><span>Now restore the values for <code>MC</code>, <code>KC</code>, and <code>NC</code>, and use your good
parameters for <code>MR</code> and <code>NR</code>. Recompile and rerun the benchmarking.
What performance do you observe now?</span></blockquote><blockquote class=exercise><h3>Exercise</h3><span><p>In addition to having good parameters, now add the pragmas to the
micro kernel in <code>micro-kernel.c</code> and rerun the same experiments again.
What performance do you observe now?</p><p>Last time I tried this, I found that I needed to stop the
<code>micro_kernel</code> being inlined by the Intel compiler for really good
performance, so change the signature to be</p><div class=highlight><pre style=color:#272822;background-color:#fafafa><code class=language-c data-lang=c><span style=color:#111>__attribute__</span><span style=color:#111>((</span><span style=color:#111>noinline</span><span style=color:#111>))</span>
<span style=color:#00a8c8>static</span> <span style=color:#00a8c8>void</span> <span style=color:#111>micro_kernel</span><span style=color:#111>(...)</span>
</code></pre></div><p>Rerun again, do you observe any further differences?</p><p>How close to peak performance does the code get?</p></span></blockquote></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/wenceorg/comp52315/commit/cdfbd8f86c56d4a17e7e322b59a75940cea4fb4e title="Last modified by Lawrence Mitchell | April 7, 2022" target=_blank rel=noopener><img src=/comp52315/svg/calendar.svg class=book-icon alt=Calendar>
<span>April 7, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/wenceorg/comp52315/edit/main/site/content//exercises/exercise09.md target=_blank rel=noopener><img src=/comp52315/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><div class="flex flex-wrap align-right"><p>© 2020&ndash; <a href=mailto:lawrence.mitchell@durham.ac.uk>Lawrence Mitchell</a> and <a href=https://www.dur.ac.uk/>Durham University</a>.</p><p><a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/><img alt="Creative Commons License" style=border-width:0 src=/comp52315/cc-by-sa.svg></a>
This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/>Creative
Commons Attribution-ShareAlike 4.0 International License</a>.</p></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#getting-compilers-to-the-right-thing>Getting compilers to the right thing</a><ul><li><a href=#does-vectorisation-occur>Does vectorisation occur</a></li><li><a href=#vectorising-the-correct-loops>Vectorising the correct loops</a></li><li><a href=#providing-more-detailed-information>Providing more detailed information</a></li><li><a href=#trying-to-maximise-throughput>Trying to maximise throughput</a></li><li><a href=#putting-it-together>Putting it together</a></li></ul></li></ul></nav></aside></main></body></html>